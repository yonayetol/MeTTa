!(import! &self variable_identifier)

;;;;;; depth generator ;;;;;; 
( = (generateDepth $size) 
    (
        if (== $size 0)
            ()
            (S (generateDepth (- $size 1)))
    )
) 

;;;;; checks membership of something in a given set of things
( = (does-exist $unknown $storage)
    (
        if (== $storage ())
            False
            (
                let*
                    (
                        ($top (car-atom $storage))
                        ($leftExpression (cdr-atom $storage))
                    )
                    
                    (
                        if (== $top $unknown)
                            True
                            (does-exist $unknown $leftExpression)
                    )
            )
    )
) 

;;;;;; checker checks whether the combo given has at-least one element from set of variables of pattern 1, return (empty) if not
( = (checker $the_real_combo $combo $var1)
    (
        if (== $combo ())
            (empty)
            (
                let*
                    (
                        ($headOfCombo (car-atom $combo))
                        ($tailOfCombo (cdr-atom $combo))
                    )
                    (
                        if (does-exist $headOfCombo $var1)  
                            $the_real_combo
                            (checker $the_real_combo $tailOfCombo $var1 )
                    )
            )
         
    )
)  

;;;;; interface with the checker function
( = (purifier $current $var1)
    (
        let () (println! (working on $current ... ))
        (checker $current $current $var1)  
    )
        
) 

;;(combiner () $joiner (generateDepth $width) 1 1 )

( = (combiner $accumulated $vars () $p1 $p2) $accumulated )
;;;;; makes combinations by pre-killing what is going to make repetition or what is un-ordered
( = (combiner $accumulated $vars (S $depth) $pointer1 $pointer2) 
    (
        let*
            (
                (($randomVar $index $patName) (superpose $vars))
                ($shouldBePreKilled  
                    (
                        if (== $patName pat1)
                            ( >= $pointer1 $index)
                            ( >= $pointer2 $index)  
                    ) 
                )
                ($joiner (union-atom $accumulated ($randomVar) ) ) 
            )
            (
                if $shouldBePreKilled
                    (empty)
                    (
                        if (== $patName pat1) 
                            (combiner $joiner $vars $depth $index $pointer2)
                            (combiner $joiner $vars $depth $pointer1 $index)
                    )
            ) 
    )
)


( = (formatter $accumulated $vars $index $patName)
    (
        if (== $vars ())
            $accumulated
            (
                let*
                    (
                        ($top (((car-atom $vars) $index $patName )))
                        ($tail (cdr-atom $vars))
                    )
                    (formatter (union-atom $accumulated $top) $tail (+ $index 1) $patName) 
            )
    )
)

;;;;; the main function the caller of everything
( = (all-variable-combination $pattern1 $pattern2)
    (
        let*
            (
                ($varsInPat1 (get-variables $pattern1))
                ($varsInPat2 (get-variables $pattern2)) 

                ($first (formatter () $varsInPat1 1 pat1))
                ($second (formatter () $varsInPat2 1 pat2))
                ($joiner (union-atom $first $second))

                (() (println! (we have got vars = $joiner)))
                
                ($width (size-atom $varsInPat2)) 
                ($unpurifiedAllCombinations (collapse (combiner () $joiner (generateDepth $width) 0 0 )) )   
            )
            
            ( let $var1Exist (collapse (purifier (superpose $unpurifiedAllCombinations) $varsInPat1)) $var1Exist )   
    )
)

!(all-variable-combination (hi this is $a) (i am $1 years $2 $3 living in city  ) ) 
