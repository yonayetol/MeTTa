!(import! &self variable_identifier)

;;;;;; depth generator ;;;;;; 
( = (generateDepth $size) 
    (
        if (== $size 0)
            ()
            (S (generateDepth (- $size 1)))
    )
) 

;;;;; checks membership of something in a given set of things
( = (does-exist $unknown $storage)
    (
        if (== $storage ())
            False
            (
                let*
                    (
                        ($top (car-atom $storage))
                        ($leftExpression (cdr-atom $storage))
                    )
                    
                    (
                        if (== $top $unknown)
                            True
                            (does-exist $unknown $leftExpression)
                    )
            )
    )
) 

;;;;; returns the false if it has repetitive variables, true if not
( = (MyUnique-expression $store $expression)  
    (
        if (== $expression ())
            True
            (
                let*
                    (
                        ($topPart (car-atom $expression))
                        ($tailPart (cdr-atom $expression))
                        ($exist (does-exist $topPart $store))
                        ($joiner (union-atom $store ($topPart)))
                    )
                    (
                        if $exist
                            False
                            (MyUnique-expression $joiner $tailPart)
                    )
            )
    ) 
)

;;;;;; checker checks whether the combo given has just one element from set of variables of patter 1, return (empty) if not
( = (checker $the_real_combo $combo $var1)
    (
        if (== $combo ())
            (empty)
            (
                let*
                    (
                        ($headOfCombo (car-atom $combo))
                        ($tailOfCombo (cdr-atom $combo))
                    )
                    (
                        if (does-exist $headOfCombo $var1)  
                            $the_real_combo
                            (checker $the_real_combo $tailOfCombo $var1 )
                    )
            )
         
    )
) 
;;;;; interface of the main function
( = (checkerCaller $combo $var1)
    (checker $combo $combo $var1)
)

;;;;; decide whether a given combination is valid or not
( = (purifier $current $var1) 
    (   let* 
        (  
            ($combinationValidity (MyUnique-expression () $current) )    
            (() (println! ($unique equals to $current ? $combinationValidity)))
        ) 
        (
            if $combinationValidity
                (checkerCaller $current $var1)
                (empty)
        )
    ) 
) 


( = (combiner $accumulated $vars ()) $accumulated )
;;;;; makes the combinations randomly for now up-to the width needed
( = (combiner $accumulated $vars (S $depth)) 
    (
        combiner (union-atom $accumulated ((superpose $vars))) $vars $depth
    )

)

;;;;; the main function the caller of everything
( = (all-variable-combination $pattern1 $pattern2)
    (
        let*
            (
                ($varsInPat1 (get-variables $pattern1))
                ($varsInPat2 (get-variables $pattern2))
                (() (println! ($varsInPat1 and $varsInPat2)))

                ($width (size-atom $varsInPat2))
                ($depthNeeded (generateDepth $width) )
                (() (println! $depthNeeded ))

                ($joined (union-atom $varsInPat1 $varsInPat2)) 
                ($unpurifiedAllCombinations (collapse (combiner () $joined $depthNeeded )) )  
            )
            
            ( let $var1Exist (collapse (purifier (superpose $unpurifiedAllCombinations) $varsInPat1)) $var1Exist )   
    )
)
 
; !(all-variable-combination (hi $this is name second) (i am $age years $old living in  $city  ) ) 
